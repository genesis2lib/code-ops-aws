name: Appinfra-Deploy (Combined)

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  TF_VERSION: "1.12.2"
  AWS_REGION: {{region}}
  AWS_ACCESS_KEY_ID: {{{githubVarsOpen}}} vars.AWS_ADMIN_ID {{{githubVarsClose}}}
  DNS_PROVIDER: {{dnsProvider}}

jobs:
  combined-deploy:
    name: Combined Infrastructure Deployment
    runs-on: ubuntu-latest
    timeout-minutes: 90
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Env setup
        run: |
          
          # Set environment variables
          echo "BRANCH={{{githubVarsOpen}}} github.ref_name {{{githubVarsClose}}}" >> $GITHUB_ENV
          if [[ "{{{githubVarsOpen}}} github.ref_name {{{githubVarsClose}}}" = "main" || "{{{githubVarsOpen}}} github.ref_name {{{githubVarsClose}}}" = "production" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          else
            BRANCH_ENV=$(echo "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" | sed "s///-/g")
            echo "ENVIRONMENT=$BRANCH_ENV" >> $GITHUB_ENV
          fi
          
          echo "âœ… Environment setup completed: {{{githubVarsOpen}}} github.ref_name {{{githubVarsClose}}}"

      # ============================
      # STEP 1: INIT (IAM & SSH KEYS)
      # ============================
      - name: "Step 1: Configure AWS credentials (Admin)"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: {{{githubVarsOpen}}} env.AWS_ACCESS_KEY_ID {{{githubVarsClose}}}
          aws-secret-access-key: {{{githubVarsOpen}}} secrets.AWS_ADMIN_SECRET {{{githubVarsClose}}}
          aws-region: {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}}

      - name: "Step 1: Create Trust Policy and Roles needed for All other github actions"
        run: |
          echo "ğŸ” Setting up GitHub OIDC Identity Provider and IAM roles..."
          
          # Create GitHub OIDC Identity Provider (if it doesn't exist)
          if ! aws iam get-open-id-connect-provider --open-id-connect-provider-arn "arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:oidc-provider/token.actions.githubusercontent.com" 2>/dev/null; then
            echo "Creating GitHub OIDC Identity Provider..."
            aws iam create-open-id-connect-provider \
              --url https://token.actions.githubusercontent.com \
              --client-id-list sts.amazonaws.com \
              --thumbprint-list 6938fd4d98bab03faadb97b34396831e3780aea1 \
              --thumbprint-list 1c58a3a8518e8759bf075b76b750d4f2df264fcd
          else
            echo "GitHub OIDC Identity Provider already exists"
          fi
          
          # Get repository information from GitHub context
          REPO_OWNER="{{{githubVarsOpen}}} github.repository_owner {{{githubVarsClose}}}"
          REPO_NAME="{{{githubVarsOpen}}} github.event.repository.name {{{githubVarsClose}}}"
          
          echo "Repository: ${REPO_OWNER}/${REPO_NAME}"
          
          # Create trust policy for GitHub Actions
          cat > /tmp/github-trust-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Federated": "arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:oidc-provider/token.actions.githubusercontent.com"
                },
                "Action": "sts:AssumeRoleWithWebIdentity",
                "Condition": {
                  "StringEquals": {
                    "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
                  },
                  "StringLike": {
                    "token.actions.githubusercontent.com:sub": "repo:${REPO_OWNER}/${REPO_NAME}:*"
                  }
                }
              }
            ]
          }
          EOF
          
          # 1. Create Terraform Role for Infrastructure Operations
          echo "ğŸ—ï¸ Creating Terraform role..."
          cat > /tmp/terraform-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "ec2:*",
                  "rds:*",
                  "s3:*",
                  "cloudfront:*",
                  "elasticloadbalancing:*",
                  "autoscaling:*",
                  "iam:*",
                  "secretsmanager:*",
                  "ssm:*",
                  "logs:*",
                  "route53:*",
                  "acm:*",
                  "dynamodb:*",
                  "cloudwatch:*"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          
          # Create or update terraform role
          aws iam create-role \
            --role-name "{{projectName}}-terraform-role" \
            --assume-role-policy-document file:///tmp/github-trust-policy.json \
            --description "Role for Terraform infrastructure operations via GitHub Actions" || \
          aws iam update-assume-role-policy \
            --role-name "{{projectName}}-terraform-role" \
            --policy-document file:///tmp/github-trust-policy.json
          
          aws iam put-role-policy \
            --role-name "{{projectName}}-terraform-role" \
            --policy-name "TerraformFullAccess" \
            --policy-document file:///tmp/terraform-policy.json
          
          # 2. Create S3 Deployment Role for Client Operations
          echo "ğŸŒ Creating S3 deployment role..."
          cat > /tmp/s3-deploy-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "s3:ListAllMyBuckets"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "s3:GetObject",
                  "s3:PutObject",
                  "s3:DeleteObject",
                  "s3:ListBucket",
                  "s3:GetBucketLocation",
                  "s3:GetBucketVersioning",
                  "s3:PutBucketVersioning",
                  "s3:GetBucketAcl",
                  "s3:PutBucketAcl",
                  "s3:GetBucketPolicy",
                  "s3:PutBucketPolicy",
                  "s3:DeleteBucketPolicy"
                ],
                "Resource": [
                  "arn:aws:s3:::*{{projectName}}*",
                  "arn:aws:s3:::*{{projectName}}*/*"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "cloudfront:CreateInvalidation",
                  "cloudfront:GetInvalidation",
                  "cloudfront:ListInvalidations",
                  "cloudfront:GetDistribution",
                  "cloudfront:GetDistributionConfig",
                  "cloudfront:ListDistributions"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          
          aws iam create-role \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-s3-role" \
            --assume-role-policy-document file:///tmp/github-trust-policy.json \
            --description "Role for S3 and CloudFront operations via GitHub Actions ({{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}})" || \
          aws iam update-assume-role-policy \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-s3-role" \
            --policy-document file:///tmp/github-trust-policy.json
          
          aws iam put-role-policy \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-s3-role" \
            --policy-name "S3CloudFrontAccess" \
            --policy-document file:///tmp/s3-deploy-policy.json
          
          # 3. Create EC2 Deployment Role for Server Operations
          echo "ğŸ–¥ï¸ Creating EC2 deployment role..."
          cat > /tmp/ec2-deploy-policy.json <<EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Action": [
                  "s3:ListAllMyBuckets"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "s3:GetObject",
                  "s3:PutObject",
                  "s3:ListBucket"
                ],
                "Resource": [
                  "arn:aws:s3:::*{{projectName}}*",
                  "arn:aws:s3:::*{{projectName}}*/*",
                  "arn:aws:s3:::{{projectName}}-*-api",
                  "arn:aws:s3:::{{projectName}}-*-api/*",
                  "arn:aws:s3:::{{projectName}}-*-ops", 
                  "arn:aws:s3:::{{projectName}}-*-ops/*"
                ]
              },
              {
                "Effect": "Allow",
                "Action": [
                  "ssm:SendCommand",
                  "ssm:GetCommandInvocation",
                  "ssm:DescribeInstanceInformation",
                  "ssm:DescribeInstances",
                  "ssm:ListCommands",
                  "ssm:ListCommandInvocations",
                  "ssm:GetParameter",
                  "ssm:GetParameters",
                  "ssm:GetParameterHistory"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "ec2:DescribeInstances",
                  "ec2:DescribeInstanceStatus",
                  "ec2:DescribeInstanceAttribute",
                  "ec2:DescribeTags"
                ],
                "Resource": "*"
              },
              {
                "Effect": "Allow",
                "Action": [
                  "autoscaling:DescribeAutoScalingGroups",
                  "autoscaling:DescribeAutoScalingInstances",
                  "autoscaling:DescribeLaunchConfigurations",
                  "autoscaling:UpdateAutoScalingGroup"
                ],
                "Resource": "*"
              }
            ]
          }
          EOF
          
          aws iam create-role \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-ec2-role" \
            --assume-role-policy-document file:///tmp/github-trust-policy.json \
            --description "Role for EC2 and SSM operations via GitHub Actions ({{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}})" || \
          aws iam update-assume-role-policy \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-ec2-role" \
            --policy-document file:///tmp/github-trust-policy.json
          
          aws iam put-role-policy \
            --role-name "{{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-ec2-role" \
            --policy-name "EC2SSMAccess" \
            --policy-document file:///tmp/ec2-deploy-policy.json
          
          echo "âœ… Successfully created all IAM roles and policies:"
          echo "   - {{projectName}}-terraform-role (Infrastructure operations)"
          echo "   - {{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-s3-role (Client deployments)"
          echo "   - {{projectName}}-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}-ops-deploy-ec2-role (Server deployments)"

      - name: "Step 1: Check and Generate SSH Keys"
        run: |
          echo "ğŸ”‘ Checking SSH keys in S3 terraform-state bucket..."
          
          # Determine the terraform state bucket name
          STATE_BUCKET="{{projectName}}-terraform-state"
          
          echo "Checking for SSH keys in bucket: $STATE_BUCKET"
          
          # Check if the bucket exists
          if ! aws s3api head-bucket --bucket "$STATE_BUCKET" 2>/dev/null; then
            echo "âš ï¸ Terraform state bucket $STATE_BUCKET doesn't exist yet"
            echo "SSH keys will be generated during bootstrap phase"
            exit 0
          fi
          
          # Check if ssh directory and keys exist for current environment
          CURRENT_ENV="{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}"
          echo "ğŸ” Checking for existing SSH keys for environment: $CURRENT_ENV"
          
          MISSING_KEYS=()
          
          # Check for environment-specific keys
          if ! aws s3 ls "s3://$STATE_BUCKET/ssh/${CURRENT_ENV}_key" >/dev/null 2>&1; then
            echo "âŒ ${CURRENT_ENV} SSH key not found"
            MISSING_KEYS+=("$CURRENT_ENV")
          else
            echo "âœ… ${CURRENT_ENV} SSH key found"
          fi
          
          if ! aws s3 ls "s3://$STATE_BUCKET/ssh/${CURRENT_ENV}_key.pub" >/dev/null 2>&1; then
            echo "âŒ ${CURRENT_ENV} SSH public key not found"
            MISSING_KEYS+=("$CURRENT_ENV")
          else
            echo "âœ… ${CURRENT_ENV} SSH public key found"
          fi
          
          # Generate missing keys
          if [ ${#MISSING_KEYS[@]} -eq 0 ]; then
            echo "âœ… All SSH keys are present in S3"
          else
            echo "ğŸ”‘ Generating missing SSH keys..."
            
            # Create temporary directory for key generation
            TEMP_DIR=$(mktemp -d)
            cd "$TEMP_DIR"
            
            # Remove duplicates from MISSING_KEYS array
            UNIQUE_MISSING=($(printf "%s\n" "${MISSING_KEYS[@]}" | sort -u))
            
            for ENV in "${UNIQUE_MISSING[@]}"; do
              echo "Generating SSH key pair for ${ENV} environment..."
              
              # Generate SSH key pair
              ssh-keygen -t rsa -b 4096 -f "${ENV}_key" -N "" -C "{{projectName}}-${ENV}"
              
              echo "âœ… Generated ${ENV}_key and ${ENV}_key.pub"
              
              # Upload to S3
              echo "ğŸ“¤ Uploading ${ENV} SSH keys to S3..."
              aws s3 cp "${ENV}_key" "s3://$STATE_BUCKET/ssh/${ENV}_key"
              aws s3 cp "${ENV}_key.pub" "s3://$STATE_BUCKET/ssh/${ENV}_key.pub"
              
              echo "âœ… Uploaded ${ENV} SSH keys to s3://$STATE_BUCKET/ssh/"
            done
            
            # Cleanup temporary directory
            cd /
            rm -rf "$TEMP_DIR"
            echo "ğŸ§¹ Cleaned up temporary files"
          fi
          
          echo "ğŸ” Final SSH key inventory in S3:"
          aws s3 ls "s3://$STATE_BUCKET/ssh/" || echo "No ssh directory found in S3"

      # Wait for IAM role propagation
      - name: "Step 1: Wait for IAM role propagation"
        run: |
          echo "â³ Waiting 30 seconds for IAM role propagation..."
          sleep 30

      # ============================
      # STEP 2: BOOTSTRAP (Terraform State & Core Infrastructure)
      # ============================
      - name: "Step 2: Configure AWS credentials (Terraform)"
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:role/{{projectName}}-terraform-role
          aws-region: {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}

      - name: "Step 2: Setup Terraform"
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: {{{githubVarsOpen}}} env.TF_VERSION  {{{githubVarsClose}}}
          terraform_wrapper: false

      - name: "Step 2: Terraform Init (Bootstrap)"
        working-directory: terraform/bootstrap
        run: |
          echo "ğŸš€ Initializing Terraform for bootstrap..."
          terraform init

      - name: "Step 2: Terraform Plan (Bootstrap)"
        working-directory: terraform/bootstrap
        run: |
          echo "ğŸ“‹ Planning Terraform bootstrap changes..."
          terraform plan \
            -var="region={{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}}" \
            -var="project_name={{projectName}}" \
            -var="environment={{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}" \
            -out=tfplan

      - name: "Step 2: Terraform Apply (Bootstrap)"
        working-directory: terraform/bootstrap
        run: |
          echo "ğŸš€ Applying Terraform bootstrap changes..."
          terraform apply -auto-approve tfplan
          
          echo "âœ… Bootstrap infrastructure created successfully"

      # Wait for S3 bucket propagation
      - name: "Step 2: Wait for S3 bucket propagation"
        run: |
          echo "â³ Waiting 30 seconds for S3 bucket propagation..."
          sleep 30

      # ============================
      # STEP 3: APPLY (Application Infrastructure)
      # ============================
      - name: "Step 3: Terraform Init (Main)"
        working-directory: terraform
        run: |
          echo "ğŸ”§ Initializing Terraform for main infrastructure..."
          terraform init -backend-config="backend-{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}.hcl"

      - name: "Step 3: Terraform Plan (Main)"
        working-directory: terraform
        run: |
          echo "ğŸ“‹ Planning Terraform main infrastructure changes..."
          terraform plan \
            -var-file="environments/{{{githubVarsOpen}}} env.ENVIRONMENT {{{githubVarsClose}}}.tfvars" \
            -out=tfplan

      - name: "Step 3: Terraform Apply (Main)"
        working-directory: terraform
        run: |
          echo "ğŸš€ Applying Terraform main infrastructure changes..."
          terraform apply -auto-approve tfplan
          
          echo "âœ… Main infrastructure deployed successfully"

      # ============================
      # STEP 4: SSL CERTIFICATE SETUP
      # ============================
      - name: "Step 4: Request SSL Certificate"
        run: |
          echo "ğŸ” Requesting SSL certificates..."
          
          # Extract required information from Terraform outputs
          cd terraform
          
          echo "ğŸ“Š Getting Terraform outputs..."
          HOSTED_ZONE_ID=$(terraform output -raw route53_hosted_zone_id)
          CLIENT_DOMAIN="{{projectName}}-ui.{{sld}}.{{tld}}"
          API_DOMAIN="{{projectName}}-api.{{sld}}.{{tld}}"
          
          echo "ğŸŒ Domains to certificate:"
          echo "  - Client: $CLIENT_DOMAIN"
          echo "  - API: $API_DOMAIN"
          echo "  - Hosted Zone: $HOSTED_ZONE_ID"
          
          # Request certificate for both domains
          echo "ğŸ“ Requesting SSL certificate..."
          CERT_ARN=$(aws acm request-certificate \
            --domain-name "$CLIENT_DOMAIN" \
            --subject-alternative-names "$API_DOMAIN" \
            --validation-method DNS \
            --region {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}} \
            --query 'CertificateArn' \
            --output text)
          
          echo "âœ… Certificate requested: $CERT_ARN"
          
          # Wait for certificate validation records to be available
          echo "â³ Waiting for certificate validation records..."
          sleep 30
          
          # Get certificate validation records
          echo "ğŸ“‹ Getting certificate validation records..."
          VALIDATION_RECORDS=$(aws acm describe-certificate \
            --certificate-arn "$CERT_ARN" \
            --region {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}} \
            --query 'Certificate.DomainValidationOptions[].ResourceRecord' \
            --output json)
          
          if [ "$VALIDATION_RECORDS" = "null" ] || [ -z "$VALIDATION_RECORDS" ]; then
            echo "âŒ No validation records found. Certificate may not be ready yet."
            echo "â³ Waiting longer for certificate validation records..."
            sleep 60
            
            VALIDATION_RECORDS=$(aws acm describe-certificate \
              --certificate-arn "$CERT_ARN" \
              --region {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}} \
              --query 'Certificate.DomainValidationOptions[].ResourceRecord' \
              --output json)
          fi
          
          if [ "$VALIDATION_RECORDS" = "null" ] || [ -z "$VALIDATION_RECORDS" ]; then
            echo "âŒ Still no validation records found after extended wait."
            echo "ğŸ” Certificate details:"
            aws acm describe-certificate --certificate-arn "$CERT_ARN" --region {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}}
            exit 1
          fi
          
          echo "ğŸ“ Validation records received:"
          echo "$VALIDATION_RECORDS"
          
          # Create DNS validation records in Route53
          echo "ğŸŒ Creating DNS validation records in Route53..."
          
          # Process each validation record
          echo "$VALIDATION_RECORDS" | jq -c '.[]' | while read -r record; do
            if [ "$record" != "null" ] && [ -n "$record" ]; then
              RECORD_NAME=$(echo "$record" | jq -r '.Name // empty')
              RECORD_VALUE=$(echo "$record" | jq -r '.Value // empty')
              RECORD_TYPE=$(echo "$record" | jq -r '.Type // empty')
              
              if [ -n "$RECORD_NAME" ] && [ -n "$RECORD_VALUE" ] && [ -n "$RECORD_TYPE" ]; then
                echo "Creating validation record: $RECORD_NAME ($RECORD_TYPE)"
                
                # Create Route53 change batch
                cat > /tmp/route53-change.json <<EOF
          {
            "Changes": [{
              "Action": "UPSERT",
              "ResourceRecordSet": {
                "Name": "$RECORD_NAME",
                "Type": "$RECORD_TYPE",
                "TTL": 300,
                "ResourceRecords": [{
                  "Value": "$RECORD_VALUE"
                }]
              }
            }]
          }
          EOF
                
                # Apply the change
                aws route53 change-resource-record-sets \
                  --hosted-zone-id "$HOSTED_ZONE_ID" \
                  --change-batch file:///tmp/route53-change.json
                
                echo "âœ… Created validation record: $RECORD_NAME"
              else
                echo "âš ï¸ Skipping incomplete record: $record"
              fi
            fi
          done
          
          echo "â³ Waiting for certificate validation (this may take 5-10 minutes)..."
          
          # Wait for certificate validation with timeout
          WAIT_COUNT=0
          MAX_WAIT=60  # 10 minutes (60 * 10 seconds)
          
          while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
            STATUS=$(aws acm describe-certificate \
              --certificate-arn "$CERT_ARN" \
              --region {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}} \
              --query 'Certificate.Status' \
              --output text)
            
            echo "Certificate status: $STATUS (attempt $((WAIT_COUNT + 1))/$MAX_WAIT)"
            
            if [ "$STATUS" = "ISSUED" ]; then
              echo "âœ… Certificate validated and issued successfully!"
              echo "Certificate ARN: $CERT_ARN"
              break
            elif [ "$STATUS" = "FAILED" ]; then
              echo "âŒ Certificate validation failed"
              aws acm describe-certificate --certificate-arn "$CERT_ARN" --region {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}}
              exit 1
            fi
            
            sleep 10
            WAIT_COUNT=$((WAIT_COUNT + 1))
          done
          
          if [ $WAIT_COUNT -eq $MAX_WAIT ]; then
            echo "â° Certificate validation timed out after 10 minutes"
            echo "ğŸ” Current certificate status:"
            aws acm describe-certificate --certificate-arn "$CERT_ARN" --region {{{githubVarsOpen}}} env.AWS_REGION {{{githubVarsClose}}}
            echo "â„¹ï¸ Certificate validation may still be in progress. Check AWS Console for status."
            echo "â„¹ï¸ You can continue with deployment once certificate is issued."
          fi

      # ============================
      # FINAL STATUS
      # ============================
      - name: "Final: Display Deployment Summary"
        run: |
          echo "ğŸ‰ Combined infrastructure deployment completed!"
          echo ""
          echo "ğŸ“‹ Deployment Summary:"
          echo "  âœ… Step 1: IAM roles and SSH keys configured"
          echo "  âœ… Step 2: Terraform state and core infrastructure bootstrapped"
          echo "  âœ… Step 3: Application infrastructure deployed"
          echo "  âœ… Step 4: SSL certificates requested"
          echo ""
          echo "ğŸ”— Next steps:"
          echo "  1. Wait for SSL certificate validation to complete (if still pending)"
          echo "  2. Deploy your applications using Code-200-Client and Code-300-Server workflows"
          echo ""
          echo "ğŸŒ Your infrastructure is ready for:"
          echo "  - Frontend: {{projectName}}-ui.{{sld}}.{{tld}}"
          echo "  - API: {{projectName}}-api.{{sld}}.{{tld}}"
          echo ""
          cd terraform 2>/dev/null && {
            echo "ğŸ” Terraform outputs:"
            terraform output || echo "No outputs available"
          } || echo "Terraform outputs not available"