name: Code-310-Server-SSL

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: {{region}}
  DNS_PROVIDER: {{dnsProvider}}

jobs:
  configure-alb-ssl:
    name: Configure ALB SSL/HTTPS
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Env setup
        run: |
          
          # Set environment variables
          echo "BRANCH={{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" >> $GITHUB_ENV
          if [[ "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "main" || "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" = "production" ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
          else
            BRANCH_ENV=$(echo "{{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}" | sed "s///-/g")
            echo "ENVIRONMENT=$BRANCH_ENV" >> $GITHUB_ENV
          fi
          
          echo "✅ Environment setup completed: {{{githubVarsOpen}}} github.ref_name  {{{githubVarsClose}}}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::{{{githubVarsOpen}}} vars.AWS_ACCOUNT_ID {{{githubVarsClose}}}:role/{{projectName}}-terraform-role
          aws-region: {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.12.2"
          terraform_wrapper: false

      - name: Get Terraform Outputs
        run: |
          cd {{id}}/terraform
          echo "🔍 Getting Terraform outputs for {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}} environment..."
          
          # Initialize Terraform to access state
          terraform init -backend-config=backend-${ENVIRONMENT}.hcl -input=false
          
          # Get the ALB DNS name from Terraform outputs
          ALB_DNS=$(terraform output -raw load_balancer_dns_name 2>/dev/null || echo "")
          
          if [ -z "$ALB_DNS" ]; then
            echo "❌ Could not get ALB DNS name from Terraform outputs"
            echo "🔍 Available Terraform outputs:"
            terraform output
            echo "⚠️ Infrastructure may not be deployed yet - run deploy_apply first"
            exit 1
          fi
          
          echo "✅ Found ALB DNS: $ALB_DNS"
          echo "ALB_DNS=$ALB_DNS" >> $GITHUB_ENV

      - name: Configure ALB SSL
        run: |
          echo "🌐 Configuring ALB SSL for {{projectName}} {{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}..."
          
          PROJECT_NAME="{{projectName}}"
          ENVIRONMENT="{{{githubVarsOpen}}} env.ENVIRONMENT  {{{githubVarsClose}}}"
          
          # Domain construction with environment-specific prefix
          if [ "${ENVIRONMENT}" = "production" ]; then
            API_DOMAIN="{{projectName}}-api.{{sld}}.{{tld}}"
          else
            API_DOMAIN="{{projectName}}-${ENVIRONMENT}-api.{{sld}}.{{tld}}"
          fi
          ALB_DNS="{{{githubVarsOpen}}} env.ALB_DNS  {{{githubVarsClose}}}"
          
          echo "📋 Configuration:"
          echo "  Project: $PROJECT_NAME"
          echo "  Environment: $ENVIRONMENT"
          echo "  API Domain: $API_DOMAIN"
          echo "  ALB DNS: $ALB_DNS"
          
          # Find the ALB using the DNS name from Terraform
          echo "🔍 Finding Application Load Balancer..."
          ALB_ARN=$(aws elbv2 describe-load-balancers \
            --query "LoadBalancers[?DNSName=='$ALB_DNS'].LoadBalancerArn" \
            --output text 2>/dev/null || true)
          
          if [ -z "$ALB_ARN" ] || [ "$ALB_ARN" = "None" ]; then
            echo "❌ ALB not found for DNS: $ALB_DNS"
            echo "This ALB may not exist or may have been deleted"
            exit 1
          fi
          
          echo "✅ Found ALB: $ALB_ARN"
          
          # Check if HTTPS listener already exists
          echo "🔍 Checking current listeners..."
          HTTPS_LISTENER=$(aws elbv2 describe-listeners \
            --load-balancer-arn "$ALB_ARN" \
            --query "Listeners[?Port==\`443\`].ListenerArn" \
            --output text 2>/dev/null || true)
          
          if [ -n "$HTTPS_LISTENER" ] && [ "$HTTPS_LISTENER" != "None" ]; then
            echo "✅ HTTPS listener already exists: $HTTPS_LISTENER"
            echo "ALB is already configured for HTTPS"
            exit 0
          fi
          
          # Find ACM certificate for the domain (ALB requires certificate in same region)
          echo "🔍 Looking for ACM certificate in {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} (ALB region)..."
          echo "🔍 Searching for domain: $API_DOMAIN"
          
          # Debug: List all certificates first
          echo "🔍 DEBUG: All available certificates in {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}:"
          aws acm list-certificates --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} --query "CertificateSummaryList[].{Domain:DomainName,SAN:SubjectAlternativeNameSummary,Arn:CertificateArn}" --output table || true
          
          CERT_ARN=$(aws acm list-certificates --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} \
            --query "CertificateSummaryList[?DomainName=='$API_DOMAIN'].CertificateArn" \
            --output text 2>/dev/null | head -1 || true)
          
          # If not found by domain name, search in SAN using a simpler approach
          if [ -z "$CERT_ARN" ] || [ "$CERT_ARN" = "None" ]; then
            echo "🔍 Searching in Subject Alternative Names..."
            # Get all certificates and search manually
            ALL_CERTS=$(aws acm list-certificates --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} --query "CertificateSummaryList[].[CertificateArn,DomainName]" --output text 2>/dev/null || true)
            while IFS=$'\t' read -r cert_arn cert_domain; do
              if [ -n "$cert_arn" ]; then
                # Get detailed certificate info to check SAN
                SAN_DOMAINS=$(aws acm describe-certificate --certificate-arn "$cert_arn" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} \
                  --query "Certificate.SubjectAlternativeNames" --output text 2>/dev/null || true)
                if echo "$SAN_DOMAINS" | grep -q "$API_DOMAIN"; then
                  CERT_ARN="$cert_arn"
                  echo "✅ Found certificate with $API_DOMAIN in SAN: $CERT_ARN"
                  break
                fi
              fi
            done <<< "$ALL_CERTS"
          fi
          
          echo "🔍 DEBUG: Query result for exact domain: '$CERT_ARN'"
          
          if [ -z "$CERT_ARN" ] || [ "$CERT_ARN" = "None" ]; then
            echo "⚠️ No ACM certificate found for domain: $API_DOMAIN"
            echo "🔍 Looking for wildcard certificate that might cover this domain..."
            
            # Check for wildcard certificates
            WILDCARD_DOMAIN="*.{{sld}}.{{tld}}"
            echo "🔍 Searching for wildcard: $WILDCARD_DOMAIN"
            
            CERT_ARN=$(aws acm list-certificates --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} \
              --query "CertificateSummaryList[?DomainName=='$WILDCARD_DOMAIN'].CertificateArn" \
              --output text 2>/dev/null | head -1 || true)
            
            # If not found by domain name, search in SAN manually
            if [ -z "$CERT_ARN" ] || [ "$CERT_ARN" = "None" ]; then
              echo "🔍 Searching wildcard in Subject Alternative Names..."
              ALL_CERTS=$(aws acm list-certificates --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} --query "CertificateSummaryList[].[CertificateArn,DomainName]" --output text 2>/dev/null || true)
              while IFS=$'\t' read -r cert_arn cert_domain; do
                if [ -n "$cert_arn" ]; then
                  # Get detailed certificate info to check SAN
                  SAN_DOMAINS=$(aws acm describe-certificate --certificate-arn "$cert_arn" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} \
                    --query "Certificate.SubjectAlternativeNames" --output text 2>/dev/null || true)
                  if echo "$SAN_DOMAINS" | grep -q "$WILDCARD_DOMAIN"; then
                    CERT_ARN="$cert_arn"
                    echo "✅ Found certificate with wildcard $WILDCARD_DOMAIN in SAN: $CERT_ARN"
                    break
                  fi
                fi
              done <<< "$ALL_CERTS"
            fi
            
            echo "🔍 DEBUG: Query result for wildcard: '$CERT_ARN'"
            
            if [ -z "$CERT_ARN" ] || [ "$CERT_ARN" = "None" ]; then
              echo "❌ No suitable certificate found in {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}. Please ensure you have a certificate for:"
              echo "  - $API_DOMAIN"
              echo "  - OR $WILDCARD_DOMAIN"
              echo ""
              echo "💡 To request a certificate (or run bootstrap workflow to create it):"
              echo "aws acm request-certificate --domain-name '$API_DOMAIN' --validation-method DNS --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}}"
              exit 1
            else
              echo "✅ Found wildcard certificate: $CERT_ARN"
            fi
          else
            echo "✅ Found certificate for domain: $CERT_ARN"
          fi
          
          # Check certificate status
          echo "🔍 Checking certificate status..."
          CERT_STATUS=$(aws acm describe-certificate --certificate-arn "$CERT_ARN" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} \
            --query 'Certificate.Status' --output text 2>/dev/null || echo "UNKNOWN")
          
          echo "Certificate status: $CERT_STATUS"
          
          if [ "$CERT_STATUS" = "PENDING_VALIDATION" ]; then
            echo "⏳ Certificate is pending validation. DNS records needed:"
            echo ""
            
            # Get DNS validation records
            aws acm describe-certificate --certificate-arn "$CERT_ARN" --region {{{githubVarsOpen}}} env.AWS_REGION  {{{githubVarsClose}}} \
              --query 'Certificate.DomainValidationOptions[].ResourceRecord.{Name:Name,Type:Type,Value:Value}' \
              --output table 2>/dev/null || true
            
            echo ""
            echo "📋 Action required:"
            echo "1. Add the CNAME records above to your DNS provider"
            echo "2. Wait for certificate validation to complete"
            echo "3. Re-run this workflow"
            exit 0
          elif [ "$CERT_STATUS" != "ISSUED" ]; then
            echo "❌ Certificate is in invalid state: $CERT_STATUS"
            echo "Expected status: ISSUED"
            exit 1
          fi
          
          echo "✅ Certificate is valid and issued"
          
          # Get target group ARN using correct naming pattern
          echo "🔍 Getting target group..."
          TARGET_GROUP_ARN=$(aws elbv2 describe-target-groups \
            --query "TargetGroups[?TargetGroupName=='$PROJECT_NAME-$ENVIRONMENT-tg'].TargetGroupArn" \
            --output text 2>/dev/null || true)
          
          if [ -z "$TARGET_GROUP_ARN" ] || [ "$TARGET_GROUP_ARN" = "None" ]; then
            echo "❌ Target group not found for $PROJECT_NAME-$ENVIRONMENT-tg"
            echo "Expected target group name: '$PROJECT_NAME-$ENVIRONMENT-tg'"
            exit 1
          fi
          
          echo "✅ Found target group: $TARGET_GROUP_ARN"
          
          # Create HTTPS listener
          echo "🔒 Creating HTTPS listener..."
          HTTPS_LISTENER_ARN=$(aws elbv2 create-listener \
            --load-balancer-arn "$ALB_ARN" \
            --protocol HTTPS \
            --port 443 \
            --ssl-policy "ELBSecurityPolicy-TLS-1-2-2017-01" \
            --certificates CertificateArn="$CERT_ARN" \
            --default-actions Type=forward,TargetGroupArn="$TARGET_GROUP_ARN" \
            --query 'Listeners[0].ListenerArn' \
            --output text 2>/dev/null || true)
          
          if [ -z "$HTTPS_LISTENER_ARN" ] || [ "$HTTPS_LISTENER_ARN" = "None" ]; then
            echo "❌ Failed to create HTTPS listener"
            exit 1
          fi
          
          echo "✅ Created HTTPS listener: $HTTPS_LISTENER_ARN"
          
          # Update HTTP listener to redirect to HTTPS
          echo "🔄 Updating HTTP listener to redirect to HTTPS..."
          HTTP_LISTENER=$(aws elbv2 describe-listeners \
            --load-balancer-arn "$ALB_ARN" \
            --query "Listeners[?Port==\`80\`].ListenerArn" \
            --output text 2>/dev/null || true)
          
          if [ -n "$HTTP_LISTENER" ] && [ "$HTTP_LISTENER" != "None" ]; then
            echo "🔄 Updating HTTP listener to redirect to HTTPS..."
            aws elbv2 modify-listener \
              --listener-arn "$HTTP_LISTENER" \
              --default-actions Type=redirect,RedirectConfig='{Protocol="HTTPS",Port="443",StatusCode="HTTP_301"}' \
              --query 'Listeners[0].ListenerArn' \
              --output text
            
            echo "✅ HTTP listener updated to redirect to HTTPS"
          else
            echo "⚠️ No HTTP listener found to update"
          fi
          
          echo "✅ ALB SSL configuration completed!"
          echo ""
          echo "📋 Summary:"
          echo "  ALB ARN: $ALB_ARN"
          echo "  ALB DNS: $ALB_DNS"
          echo "  HTTPS Listener: $HTTPS_LISTENER_ARN"
          echo "  Certificate: $CERT_ARN"
          echo "  Target Group: $TARGET_GROUP_ARN"
          echo ""
          echo "🌐 Your API will be available at:"
          echo "  HTTP: http://$ALB_DNS (redirects to HTTPS)"
          echo "  HTTPS: https://$ALB_DNS"
          echo ""
          echo "🔒 SSL/TLS Configuration:"
          echo "  - Protocol: HTTPS"
          echo "  - Port: 443"
          echo "  - SSL Policy: ELBSecurityPolicy-TLS-1-2-2017-01"
          echo "  - Certificate: $CERT_ARN"
          echo ""
          echo "⚠️ Note: If you have a custom domain, you'll need to:"
          echo "1. Point your domain to the ALB DNS: $ALB_DNS"
          echo "2. Or use Route 53 to create an alias record"
          echo ""
          echo "🧪 Test your HTTPS endpoint:"
          echo "curl -k https://$ALB_DNS/app/v1/health"

      - name: Update Cloudflare DNS for ALB
        run: |
          echo "🔍 Checking for DNS provider API key..."
          
          # Check if DNS_PROVIDER_KEY secret is available
          if [ -z "{{{githubVarsOpen}}} secrets.DNS_PROVIDER_KEY  {{{githubVarsClose}}}" ]; then
            echo "⚠️ No DNS_PROVIDER_KEY secret found. Skipping DNS management."
            exit 0
          fi
          
          # Check if DNS_PROVIDER is set and supported
          if [ -z "{{{githubVarsOpen}}} env.DNS_PROVIDER  {{{githubVarsClose}}}" ]; then
            echo "⚠️ DNS_PROVIDER environment variable not set. Skipping DNS management."
            exit 0
          fi
          
          # Currently only support Cloudflare
          if [ "{{{githubVarsOpen}}} env.DNS_PROVIDER  {{{githubVarsClose}}}" != "cloudflare" ]; then
            echo "⚠️ DNS provider '{{{githubVarsOpen}}} env.DNS_PROVIDER  {{{githubVarsClose}}}' not supported. Currently only 'cloudflare' is supported."
            exit 0
          fi
          
          echo "✅ DNS provider API key found and provider 'cloudflare' is supported"
          echo "🚀 Attempting to update Cloudflare DNS records..."
          
          # Get ALB DNS name from environment
          ALB_DNS="{{{githubVarsOpen}}} env.ALB_DNS  {{{githubVarsClose}}}"
          
          if [ -z "$ALB_DNS" ]; then
            echo "❌ Could not get ALB DNS name"
            exit 1
          fi
          
          echo "✅ ALB DNS: $ALB_DNS"
          
          # Domain construction with environment-specific prefix
          if [ "${ENVIRONMENT}" = "production" ]; then
            API_DOMAIN="{{projectName}}-api.{{sld}}.{{tld}}"
          else
            API_DOMAIN="{{projectName}}-${ENVIRONMENT}-api.{{sld}}.{{tld}}"
          fi
          DOMAIN_BASE="{{sld}}.{{tld}}"
          
          echo "📋 DNS Configuration:"
          echo "  CNAME Name: $API_DOMAIN"
          echo "  CNAME Value: $ALB_DNS"
          echo "  Zone: $DOMAIN_BASE"
          
          # Function to check if CNAME record exists in Cloudflare
          check_cloudflare_record() {
            local zone_name="$1"
            local record_name="$2"
            local api_token="$3"
            
            # Get zone ID
            local zone_id=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$zone_name" \
              -H "Authorization: Bearer $api_token" \
              -H "Content-Type: application/json" | jq -r '.result[0].id' 2>/dev/null)
            
            if [ "$zone_id" = "null" ] || [ -z "$zone_id" ]; then
              echo "❌ Could not find Cloudflare zone for: $zone_name"
              return 1
            fi
            
            # Check if CNAME record exists
            local existing_record=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$zone_id/dns_records?type=CNAME&name=$record_name" \
              -H "Authorization: Bearer $api_token" \
              -H "Content-Type: application/json" | jq -r '.result[0].id' 2>/dev/null)
            
            if [ "$existing_record" = "null" ] || [ -z "$existing_record" ]; then
              echo "false"
            else
              echo "true"
            fi
          }
          
          # Function to get existing CNAME record ID and value
          get_cloudflare_record_info() {
            local zone_name="$1"
            local record_name="$2"
            local api_token="$3"
            
            # Get zone ID
            local zone_id=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$zone_name" \
              -H "Authorization: Bearer $api_token" \
              -H "Content-Type: application/json" | jq -r '.result[0].id' 2>/dev/null)
            
            if [ "$zone_id" = "null" ] || [ -z "$zone_id" ]; then
              echo "❌ Could not find Cloudflare zone for: $zone_name"
              return 1
            fi
            
            # Get CNAME record details
            local record_data=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones/$zone_id/dns_records?type=CNAME&name=$record_name" \
              -H "Authorization: Bearer $api_token" \
              -H "Content-Type: application/json" | jq -r '.result[0]' 2>/dev/null)
            
            if [ "$record_data" = "null" ] || [ -z "$record_data" ]; then
              echo "false"
            else
              echo "$record_data"
            fi
          }
          
          # Function to add CNAME record to Cloudflare
          add_cloudflare_record() {
            local zone_name="$1"
            local record_name="$2"
            local record_value="$3"
            local api_token="$4"
            
            # Get zone ID
            local zone_id=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$zone_name" \
              -H "Authorization: Bearer $api_token" \
              -H "Content-Type: application/json" | jq -r '.result[0].id' 2>/dev/null)
            
            if [ "$zone_id" = "null" ] || [ -z "$zone_id" ]; then
              echo "❌ Could not find Cloudflare zone for: $zone_name"
              return 1
            fi
            
            # Add CNAME record
            local response=$(curl -s -X POST "https://api.cloudflare.com/client/v4/zones/$zone_id/dns_records" \
              -H "Authorization: Bearer $api_token" \
              -H "Content-Type: application/json" \
              -d "{
                \"type\": \"CNAME\",
                \"name\": \"$record_name\",
                \"content\": \"$record_value\",
                \"ttl\": 300,
                \"proxied\": true
              }")
            
            local success=$(echo "$response" | jq -r '.success' 2>/dev/null)
            if [ "$success" = "true" ]; then
              echo "✅ Added CNAME record: $record_name -> $record_value"
              return 0
            else
              local error=$(echo "$response" | jq -r '.errors[0].message' 2>/dev/null)
              echo "❌ Failed to add CNAME record: $error"
              return 1
            fi
          }
          
          # Function to update CNAME record in Cloudflare
          update_cloudflare_record() {
            local zone_name="$1"
            local record_id="$2"
            local record_name="$3"
            local record_value="$4"
            local api_token="$5"
            
            # Get zone ID
            local zone_id=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$zone_name" \
              -H "Authorization: Bearer $api_token" \
              -H "Content-Type: application/json" | jq -r '.result[0].id' 2>/dev/null)
            
            if [ "$zone_id" = "null" ] || [ -z "$zone_id" ]; then
              echo "❌ Could not find Cloudflare zone for: $zone_name"
              return 1
            fi
            
            # Update CNAME record
            local response=$(curl -s -X PUT "https://api.cloudflare.com/client/v4/zones/$zone_id/dns_records/$record_id" \
              -H "Authorization: Bearer $api_token" \
              -H "Content-Type: application/json" \
              -d "{
                \"type\": \"CNAME\",
                \"name\": \"$record_name\",
                \"content\": \"$record_value\",
                \"ttl\": 300,
                \"proxied\": true
              }")
            
            local success=$(echo "$response" | jq -r '.success' 2>/dev/null)
            if [ "$success" = "true" ]; then
              echo "✅ Updated CNAME record: $record_name -> $record_value"
              return 0
            else
              local error=$(echo "$response" | jq -r '.errors[0].message' 2>/dev/null)
              echo "❌ Failed to update CNAME record: $error"
              return 1
            fi
          }
          
          # Test Cloudflare API connectivity
          echo "🔍 Testing Cloudflare API connectivity..."
          test_response=$(curl -s -X GET "https://api.cloudflare.com/client/v4/zones?name=$DOMAIN_BASE" \
            -H "Authorization: Bearer {{{githubVarsOpen}}} secrets.DNS_PROVIDER_KEY  {{{githubVarsClose}}}" \
            -H "Content-Type: application/json" 2>/dev/null || echo '{"success":false}')
          
          if echo "$test_response" | jq -e '.success' >/dev/null 2>&1; then
            echo "✅ Cloudflare API connectivity test successful"
          else
            echo "❌ Cloudflare API connectivity test failed. Skipping DNS management."
            exit 0
          fi
          
          # Check if CNAME record exists
          echo "🔍 Checking if CNAME record exists..."
          record_exists=$(check_cloudflare_record "$DOMAIN_BASE" "$API_DOMAIN" "{{{githubVarsOpen}}} secrets.DNS_PROVIDER_KEY  {{{githubVarsClose}}}")
          
          if [ "$record_exists" = "true" ]; then
            echo "✅ CNAME record exists, checking if update is needed..."
            
            # Get existing record info
            record_info=$(get_cloudflare_record_info "$DOMAIN_BASE" "$API_DOMAIN" "{{{githubVarsOpen}}} secrets.DNS_PROVIDER_KEY  {{{githubVarsClose}}}")
            
            if [ "$record_info" != "false" ]; then
              existing_value=$(echo "$record_info" | jq -r '.content' 2>/dev/null)
              record_id=$(echo "$record_info" | jq -r '.id' 2>/dev/null)
              
              echo "Current CNAME value: $existing_value"
              echo "New CNAME value: $ALB_DNS"
              
              if [ "$existing_value" = "$ALB_DNS" ]; then
                echo "✅ CNAME record is already up to date"
              else
                echo "🔄 Updating CNAME record..."
                update_cloudflare_record "$DOMAIN_BASE" "$record_id" "$API_DOMAIN" "$ALB_DNS" "{{{githubVarsOpen}}} secrets.DNS_PROVIDER_KEY  {{{githubVarsClose}}}"
              fi
            else
              echo "⚠️ Could not get existing record info, creating new record..."
              add_cloudflare_record "$DOMAIN_BASE" "$API_DOMAIN" "$ALB_DNS" "{{{githubVarsOpen}}} secrets.DNS_PROVIDER_KEY  {{{githubVarsClose}}}"
            fi
          else
            echo "➕ Creating new CNAME record..."
            add_cloudflare_record "$DOMAIN_BASE" "$API_DOMAIN" "$ALB_DNS" "{{{githubVarsOpen}}} secrets.DNS_PROVIDER_KEY  {{{githubVarsClose}}}"
          fi
          
          echo "✅ Cloudflare DNS management completed!"
          echo ""
          echo "📋 DNS Summary:"
          echo "  CNAME: $API_DOMAIN -> $ALB_DNS"
          echo "  Zone: $DOMAIN_BASE"
          echo ""
          echo "🌐 Your API will be available at:"
          echo "  HTTP: http://$API_DOMAIN (redirects to HTTPS)"
          echo "  HTTPS: https://$API_DOMAIN"
          echo "⏳ DNS propagation may take a few minutes"
          